---
layout: post
title:  "프로세스의 개념과 상태 변화"
date:   "2023-02-06"
category: "tech"
tags: ["운영체제", "운영체제 스터디"]
---
### 프로세스의 개념

프로세스는 **프로그램이 실행중인 상태 라고 정의합니다.** 

프로그램 자체는 디스크에 적재되어있는 상태로, 아무런 동작을 하지 않습니다. 프로그램이 메모리에 적재되고, CPU를 점유해 사용하는 주체를 “프로세스”라고 합니다. 

조금 더 구체적으로는 아래와 같이 정의할 수 있습니다.

- 커널에 등록되고 커널의 관리 하에 있는 작업
    - → **프로세스 관리 블록(PCB)을 할당받은 프로그램**
- 각종 자원을 요청하고 할당받을 수 있는 개체

### CPU 가상화와 프로세스 → 이건 CPU 가상화에 대한 설명..

이런 “프로세스”는 실제 맥이나 윈도우같은 운영체제를 사용하면서 확인할 수 있는데, 한눈에 봐도 우리는 수십개의 프로그램을 동시에 사용할 수 있다는것을 알 수 있습니다. 마치 **프로그램 하나가 CPU하나를 점유하듯**, 노래를 들으며 워드를 사용하고, 백신 프로그램을 돌리는 등, 여러가지 작업을 한번에 수행 할 수 있죠. 

이것은 모두 “**CPU 가상화**”에 기초합니다. 운영체제는 “**시분할**”을 통해 여러 프로세스가 하나의 CPU를 나눠 사용할 수 있도록 합니다.

또한 운영체제는 **과거 정보( 자주 실행된 프로그램, 실행된 프로그램의 유형)**과 **목적(처리량, 응답시간)**을 바탕으로 어떤 프로세스가 언제 CPU를 사용할지에 대한 “**스케쥴링 정책**”을 가지고있습니다. 

위같은 정책이나 시분할 기법은 프로세스가 온전히 하나의 CPU를 사용하는것”처럼” 하게 해주며, 이를 가상화 라고 부릅니다.

### 컴퓨터 구조와 프로세스

프로세스의 실행을 조금 더 가까이에서 살펴보겠습니다. 메모리와 CPU사이에 캐시, MMU, 레지스터 등 다양한 주변기기가 있지만, 설명에서는 생략합니다.

앞서 프로세스의 “실행”은 시분할과 이를 제어하는 스케쥴링 기법을 통한 CPU 가상화를 통해 이뤄진다고 말씀드렸습니다. 우리가 program.c로 작성해 program.exe파일로  컴파일된 **“파일” 이 어떻게 실행중인 “프로세스”로 변경**되는지 이해하기 위해서는 아래 그림에 대한 설명이 필요합니다. 

![1](https://user-images.githubusercontent.com/30853787/226092562-a562242a-d948-46cd-8b5e-d68edcd3d0c0.png)


프로그래머가 작성한 소스코드는 파일로 저장되며, 언어에 따라 컴파일을 통해 실행 프로그램으로 변경됩니다. 

변경된 프로그램은 실행 시 메인 메모리에 적재되고, 프로그램 코드와 정적 데이터를 저장하며 **실행중 사용할 수 있는 공간인 스택과 힙을 할당**받아 명령어에 필요한 데이터를 사용하거나 명령어를 수행한 결과를 저장합니다.  

사실. 밑에서 공부할 프로세스의 상태에서는 CPU,Memory등을 할당받지 못한(Swap된) 상태도 있기때문에, 메모리에 적재된 프로그램만 프로세스라고 부르기에는 애매합니다. PCB도 조금 이따 볼거지만, “**커널에 PCB가 저장된 프로그램**”을 프로세스로 보시는게 더 정확합니다. 

여기서 중요한 개념 중 하나인 **메모리 가상화**가 등장합니다.

메모리 가상화는 많은 역시 “**많은프로세스가 자신의 독립된 주소 공간을 갖는것처럼 행동**"할 수 있도록 해주며, MMU가 실제 주소와 가상 주소를 저장한 테이블을 통해 변환해 각각의 프로세스가 주소공간을 서로 침범하지 않고 독립적으로 실행됩니다. 

(컴퓨터구조 여담)

위 그림에서 왼쪽이 CPU와 고속처리장치(메모리컨트롤러, GPU, PCI 16x)들을 담당하는 노스브릿지(North Bridge), 오른쪽에서 메모리 아랫쪽이 저속처리장치(디스크, PCI 1x, USB, SATA 등)를 담당하는 사우스브릿지(South Bridge)인데, 주변장치와 데이터 버스를 통해 처리되던 노스브릿지 장치들이 CPU로 통합되면서 최신 CPU에는 노스브릿지 영역이 없는 형태의 CPU가 대부분이라고 합니다.

## 프로세스 상태

![2](https://user-images.githubusercontent.com/30853787/226092567-88d743d6-7d8e-483b-b183-c352a67b440b.png)


프로세스는 “스케쥴링 정책”을 통해 CPU와 메모리를 할당받는지 여부에 따라 아래와 같은 상태를 갖습니다. 

- **Created:** 커널에 PCB가 할당되고, **가용 메모리공간을 체크해 Ready상태 또는 Suspend-Ready상태로 전이**합니다.
- **Ready**: 프로세서(CPU) 할당을 대기하는 상태로, 즉시 실행 가능한 상태입니다.
    - **Schedule(또는 dispatch)**: 스케쥴링 정책에 의해 Running상태로 전이합니다.
- **Running**:  프로세서를 포함해 필요한 자원을 모두 할당받아 동작하는 상태입니다.
    - timer run-out: Running상태의 프로세스가 스케쥴 계획에 있던 시간을 모두 버스트해 종료합니다.
    - **Block/sleep:** I/O자원할당을 위해 잠시 대기합니다.
- **Asleep(Block)**: I/O가 끝나기를 기다리는 상태입니다. 자원별로 Block-Queue를 가지며, 할당이 끝나기를 기다리는 프로세스가 큐에 있습니다.
    - **Wake up**: 자원할당을 마치고 ready queue로 들어갑니다.
- **Suspended State: 메모리를 할당받지 못하고, 디스크(Swap device)에 메모리 이미지를 저장한 상태**
    - Swap in: 스왑 이미지를 메모리에 적재해 Ready 또는 Asleep 상태로 변경
    - Swap out: 적재된 메모리  영역을 스왑 디바이스에 이미지로 저장
- **Terminate:** 프로세스 수행이 끝나 모든 자원 반납 후 PCB만 커널 내에 남아있는 상태입니다.
    - 커널이 이후 비슷한 프로세스를 실행할 때, PCB정보를 참고한다고 합니다.

### PCB를 통한 프로세스의 관리

PCB: Process Control Block - **실행중인 프로그램(프로세스)들을 제어하는데 필요한 정보**를 가지고있는 자료구조 입니다.

시작/종료가 많은 프로세스의 특성 상 PCB 리스트 역시 삽입/삭제가 많은 데이터이므로,  **커널 영역에서 LinkedList를 통해 관리됩니다.**

- PCB의 구성요소: 운영체제별로 다릅니다.

| 구성요소 | 설명 |
| --- | --- |
| PID: Process Identification Number | 프로세스를 고유하게 식별하는 번호 |
| 스케쥴링 정보 | 우선순위 등 스케쥴링을 위해 필요한 정보 |
| 메모리 관리 정보 | 할당된 페이지, 세그먼트에 대한 정보 |
| 입출력상태 정보 | 할당받은 입출력 장치 |
| 문맥 저장 영역 | CPU 레지스터 저장, 문맥 교환 시 load/store하는 부분 |
| 계정정보 | 프로세스의 소유자 |

 > 멀티프로세스보다 멀티스레드가 빠른 “실질적인” 이유 

프로세스 A의 실행정보라고 불리는 **스택과 힙**에 대해 이야기해봅시다. **컴파일타임에 메모리를 할당받는 스택**의 경우, 일반적으로 1MB를 사용하고 최대 10MB정도인 반면, **힙영역은 런타임에 할당되고 최대 256MB**또는 설정에 따라 메모리의 최대크기에 따라 더 커질수도 있습니다. 

프로세스 A의 PCB에는 A가 실행될 때의 레지스터 정보들을 가지고있습니다. 또한, CPU와 근접해있는 L1, L2캐시에도 프로세스 A의 실행정보들이 **캐싱**되어있습니다. 만약 프로세스 A가 B로 Context Switch할때는 레지스터 정보를 교체하겠지만, **이후에는 L1,L2뿐만아니라 다른 캐시, 심지에 페이지 교체까지 일어납니다.** 

스레드의 경우는 어떨까요~? 스레드는 프로세스 내에서 독립적인 스택포인터(스택)을 갖지만, **실행정보에 대부분을 차지하는 힙,코드,데이터영역을 공유합니다**. 스레드의 정보를 저장한 TCB의 정보를 레지스터에 옮기는 시간은 있겠지만, 캐시,페이지 미스가 많이 일어나지 않기때문에, 훨씬 더 빠릅니다. 

+) 멀티스레드는 공유자원인 힙, 데이터에 대해 동시성 문제가 발생하므로, 동기화 문제를 꼭 핸들링해주어야 합니다!

### 키워드 & 질문 목록

PCB어떤 자료구조로 관리되며, 왜 해당 자료구조를 사용하는지 설명해주세요

프로세스의 상태와 각 상태별로 사용하고있는 자원의 종류에 대해 설명해주세요 

멀티프로세스보다 멀티스레드가 빠른 이유를 설명해주세요

문맥교환영역에 저장되는 CPU 레지스터 종류? 

PC (Program Counter) : 다음 인출(Fetch) 될 명령어의 주소를 가지고 있는 레지스터

AC (Accumulator) : 연산 결과 데이터를 일시적으로 저장하는 레지스터

IR (Instruction Register) : 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터

SR (Status Register) : 현재 CPU 의 상태를 가지고 있는 레지스터

MAR (Memory Address Register) : PC 에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터

MBR (Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터

## Reference

[**HPC Lab. KOREATECH, OS Lecture CH.3 Process](**[https://www.youtube.com/watch?v=jZuTw2tRT7w](https://www.youtube.com/watch?v=jZuTw2tRT7w) **)**

[OSTEP: Operating Systems: Three Easy Pieces]([https://pages.cs.wisc.edu/~remzi/OSTEP/](https://pages.cs.wisc.edu/~remzi/OSTEP/))

이글은 꼭 이해하면 좋을것같다. 까먹으면 다시보자! → [https://quasarzone.com/bbs/qn_hardware/views/818208](https://quasarzone.com/bbs/qn_hardware/views/818208)